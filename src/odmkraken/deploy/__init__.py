import typing
import psycopg2
import psycopg2.errors
from psycopg2 import sql as sql
from pathlib import Path
import jinja2
from contextlib import contextmanager


__here__ = Path(__file__).absolute().parent


def execute_sql_template(conn, template: str, **kwargs):
    """Generate a complex SQL instruction `str` from a file.
    
    Args:
        template: name of the file to look for - must be in this module's parent directory.
    """
    kwargs = {k: (v.as_string(conn) if hasattr(v, 'as_string') else v) for k, v in kwargs.items()}
    loader = jinja2.FileSystemLoader(__here__)
    env = jinja2.Environment(loader=loader)
    env.filters['li'] = lambda r: sql.Literal(r).as_string(conn)
    env.filters['id'] = lambda r: sql.Identifier(r).as_string(conn)
    tpl = env.get_template(template)
    
    with conn.cursor() as cur:
        cur.execute(tpl.render(**kwargs))


class DB:
    """A wrapper around a psycopg2 connection."""

    def __init__(self, **kwargs):
        """Create a new instance.
        
        Keyword arguments:
            (any understood by `psycopg2.connect`)
        """
        self._connargs = kwargs

    @contextmanager
    def connect(self, dbname: typing.Optional[str]=None, autocommit=False):
        """Connect to database and close when done.

        This context manager opens a connection to the specified datatabase,
        commits and closes it on return, and ensures the connection is rolled
        back on any `psycopg2.Error`.
        
        Arguments:
            dbname: the database to connect to. If None, do not connect to
                the management database (useful to create or drop other catalogues)
            autocommit: puts the connection into autocommit mode, meaning
                commands are committed after every call to `execute`. This
                is necessary to execute commands that need to run outside of
                a transaction block (such as `create database`). (default: False)
        """
        dbname = self._connargs.get('database') if dbname is None else str(dbname)
        conn = psycopg2.connect(database=dbname, **self._connargs)
        if autocommit:
            conn.set_session(autocommit=True)

        try:
            yield conn
            conn.commit()
        except psycopg2.Error:
            conn.rollback()
            raise
        finally:
            conn.close()

    def execute(self, query: sql.SQL, autocommit: bool=True, **kwargs):
        """Execute a single query in an isolated session.
        
        Arguments:
            query: the SQL expression to execute. Any literal values need to be
                injected beforehand into `query` as a `psycopg2.sql.Literal`.
            autocommit: same as `DB.connect`, but defaults to True.
            (any accepted by `DB.connect`)
        """
        with self.connect(autocommit=autocommit, **kwargs) as conn, conn.cursor() as cur:
            cur.execute(query)

    def run_script(self, script: str, param: typing.Dict={}, **kwargs):
        """Execute SQL generated by a Jinja2 template.
        
        Arguments:
            script: the name of a Jinja2 template.
            param: a dictionary of substitution values for Jinja
            (any understood by `DB.connect`)
        """
        with self.connect(**kwargs) as conn:
            execute_sql_template(conn, script, **param)

    @property
    def address(self):
        return (self._connargs['host'], self._connargs['port'])